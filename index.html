<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>Docker</title>
</head>
<body><h1 id='docker'>Docker</h1>
<hr />
<blockquote><p>Docker学习</p>
</blockquote>
<ul>
<li><p>Docker概述</p>
</li>
<li><p>Docker安装</p>
</li>
<li><p>Docker命令</p>
<ul>
<li>镜像命令</li>
<li>容器命令</li>
<li>操作命令</li>
<li>······</li>

</ul>
</li>
<li><p>Docker镜像</p>
</li>
<li><p>容器数据卷</p>
</li>
<li><p>DockerFile</p>
</li>
<li><p>Docker网络原理</p>
</li>
<li><p>IDEA整合Docker</p>
</li>
<li><p>Docker Compose</p>
</li>
<li><p>Docker Swarm</p>
</li>
<li><p>CI\CD Jenkins</p>
</li>

</ul>
<h2 id='docker概述'>Docker概述</h2>
<h3 id='docker为什么会出现'>Docker为什么会出现？</h3>
<ul>
<li><p>一块产品：</p>
<ul>
<li>开发----&gt;上线  两套环境：开发环境和生产环境 部署后要重新配置</li>
<li>开发环境----运维环境  我的电脑上可以，服务器上怎么就不行</li>

</ul>
</li>
<li><p>传统开发：开发人员提供jar包    运维来部署</p>
</li>
<li><p>现在：开发打包部署</p>
</li>

</ul>
<p>&nbsp;</p>
<p>Docker给以上的问题提出了解决方案:</p>
<p>Java项目-----&gt;jar+环境------&gt;Docker仓库------&gt;部署</p>
<p>部署不需要在去配置环境，在打包阶段已经集成</p>
<p>隔离：Docker核心思想！打包装箱！每个箱子都是相互隔离的！</p>
<h3 id='docker文档'>Docker文档</h3>
<p>官方网站</p>
<blockquote><p>docker.com</p>
</blockquote>
<p>官方文档</p>
<blockquote><p>docs.docker.com</p>
</blockquote>
<p>DockerHub</p>
<blockquote><p>hub.docker.com</p>
</blockquote>
<h3 id='docker能干嘛'>Docker能干嘛</h3>
<blockquote><p>虚拟机技术缺点</p>
</blockquote>
<ol start='' >
<li>资源占用多</li>
<li>荣誉步骤多</li>
<li>启动慢</li>

</ol>
<blockquote><p>容器化技术</p>
</blockquote>
<p>容器化技术不是模拟一个完整的计算机系统</p>
<p>相比于虚拟机 Docker：</p>
<ul>
<li>传统虚拟机，虚拟出一套硬件，在虚拟硬件的基础上运行一个完整的操作系统，在系统上再运行其他软件。</li>
<li>容器内的应用直接运行在<strong>宿主机内核</strong>，容器是没有自己的内核的，也没有虚拟硬件。更轻便。</li>
<li>每个容器是相互隔离的，每个容器内都有一个自己的文件系统。</li>

</ul>
<blockquote><p>DevOps(开发/运维)</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<p>传统：一堆帮助文档，安装部署程序</p>
<p>Docker:打包镜像 发布测试，一次运行</p>
<p><strong>更便捷的升级和扩容缩容</strong></p>
<p>使用Docker和积木一样</p>
<p>更快速的水平扩展  服务器A---(克隆)---&gt;服务器B</p>
<p><strong>更简单的系统运维</strong></p>
<p>容器化之后，开发和测试环境高度一致</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上运行很多的容器实例。服务器性能可以被更充分利用。</p>
<h1 id='docker-安装'>Docker 安装</h1>
<hr />
<h2 id='docker的基本组成'>Docker的基本组成</h2>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\image-20230420133548703.png" referrerpolicy="no-referrer" alt="image-20230420133548703"></p>
<p><strong>镜像（image）：</strong></p>
<p>Docker镜像一个模板，可以通过这个模板来创建容器服务（实例）</p>
<p>通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器当中）</p>
<p><strong>容器（container）：</strong></p>
<p>Docker利用容器技术，独立运行一个或一组应用，通过镜像来创建</p>
<p>目前就可以把容器理解为一个简易的linux系统</p>
<p><strong>仓库：</strong></p>
<p>仓库就是存放镜像的地方</p>
<p>仓库分为私有仓库和公有仓库</p>
<p>DockerHub(默认)</p>
<h2 id='安装docker'>安装Docker</h2>
<blockquote><p>环境</p>
</blockquote>
<ol start='' >
<li>Linux基础</li>
<li>CentOS</li>
<li>Xshell</li>

</ol>
<blockquote><p>环境查看</p>
</blockquote>
<pre><code>[root@HW-GDW ~]# uname -r
#系统内核是 3.10 以上
4.18.0-348.7.1.el8_5.x86_64
</code></pre>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW ~]# cat /etc/os-release 
NAME=&quot;CentOS Linux&quot;
VERSION=&quot;8 (Core)&quot;
ID=&quot;centos&quot;
ID_LIKE=&quot;rhel fedora&quot;
VERSION_ID=&quot;8&quot;
PLATFORM_ID=&quot;platform:el8&quot;
PRETTY_NAME=&quot;CentOS Linux 8 (Core)&quot;
ANSI_COLOR=&quot;0;31&quot;
CPE_NAME=&quot;cpe:/o:centos:centos:8&quot;
HOME_URL=&quot;https://www.centos.org/&quot;
BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;

CENTOS_MANTISBT_PROJECT=&quot;CentOS-8&quot;
CENTOS_MANTISBT_PROJECT_VERSION=&quot;8&quot;
REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;
REDHAT_SUPPORT_PRODUCT_VERSION=&quot;8&quot;
</code></pre>
<blockquote><p>安装</p>
</blockquote>
<p><strong>帮助文档：</strong></p>
<ol start='' >
<li>卸载旧版本</li>

</ol>
<pre><code class='language-shell' lang='shell'>yum remove docker \
                   docker-client \
                   docker-client-latest \
                   docker-common \
                   docker-latest \
                   docker-latest-logrotate \
                   docker-logrotate \
                   docker-engine
</code></pre>
<ol start='2' >
<li>安装依赖</li>

</ol>
<pre><code class='language-shell' lang='shell'>yum install -y yum-utils
</code></pre>
<ol start='3' >
<li>设置镜像仓库</li>

</ol>
<pre><code class='language-shell' lang='shell'>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<ol start='4' >
<li>刷新yum缓存</li>

</ol>
<pre><code class='language-shell' lang='shell'>yum makecache fast
</code></pre>
<ol start='5' >
<li>安装Docker引擎</li>

</ol>
<pre><code class='language-shell' lang='shell'>yum install docker-ce docker-ce-cli containerd.io
</code></pre>
<ol start='6' >
<li>启动Docker</li>

</ol>
<pre><code class='language-shell' lang='shell'>systemctl start docker
</code></pre>
<ol start='7' >
<li>使用 dockeversion验证安装是否成功</li>

</ol>
<pre><code class='language-shell' lang='shell'>docker version
</code></pre>
<ol start='8' >
<li>通过Hello-World测试运行是否正常</li>

</ol>
<pre><code class='language-shell' lang='shell'>docker run hello-world
</code></pre>
<ol start='9' >
<li>查看拉取的镜像</li>

</ol>
<pre><code class='language-shell' lang='shell'>docker images
</code></pre>
<ol start='10' >
<li><p>设置镜像加速</p>
<ol start='' >
<li>在/etc/docker/目录下创建daemon.json文件</li>
<li>添加镜像</li>

</ol>
<pre><code class='language-shell' lang='shell'>{
    &quot;registry-mirrors&quot;: [ &quot;https://2d38a4a8b99e4787bc89d822dea61d31.mirror.swr.myhuaweicloud.com&quot; ]
}
</code></pre>
<ol start='3' >
<li>重新加载Docker</li>

</ol>
<pre><code class='language-shell' lang='shell'>systemctl daemon-reload
</code></pre>
<ol start='4' >
<li>重启Docker</li>

</ol>
<pre><code class='language-shell' lang='shell'>systemctl restart docker
</code></pre>
<ol start='5' >
<li>检查是否成功</li>

</ol>
<pre><code class='language-shell' lang='shell'>docker info
</code></pre>
</li>

</ol>
<blockquote><p>卸载Docker</p>
</blockquote>
<ol start='' >
<li>卸载程序</li>

</ol>
<pre><code class='language-shell' lang='shell'>yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras
</code></pre>
<ol start='2' >
<li>移除资源目录</li>

</ol>
<pre><code class='language-shell' lang='shell'>rm -rf /var/lib/docker
rm -rf /var/lib/containerd
</code></pre>
<h1 id='docker常用命令'>Docker常用命令</h1>
<hr />
<h2 id='帮助命令'>帮助命令</h2>
<pre><code class='language-shell' lang='shell'>docker version				#显示版本信息
docker info					#显示Docker系统信息，包括镜像信息
docker [命令] --help		   #帮助命令
</code></pre>
<h2 id='镜像命令'>镜像命令</h2>
<h3 id='查看容器'>查看容器</h3>
<blockquote><p>docker images</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>REPOSITORY    TAG       IMAGE ID       CREATED         SIZE
hello-world   latest    feb5d9fea6a5   19 months ago   13.3kB

#返回结果注释
REPOSITORY		#仓库名
TAG				#版本标识
IMAGE ID		#仓库ID
CREATED			#创建时间
SIZE			#占用空间

#可选项
Options:
  -a, --all             #显示所有已拉取的镜像
  -q, --quiet           #显示所有已拉取的镜像的ID
</code></pre>
<h3 id='搜索镜像'>搜索镜像</h3>
<blockquote><p>docker search [镜像名]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>NAME                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
mysql                           MySQL is a widely used, open-source relation…   14051     [OK]       
mariadb                         MariaDB Server is a high performing open sou…   5367      [OK]       
percona                         Percona Server is a fork of the MySQL relati…   605       [OK]       
phpmyadmin                      phpMyAdmin - A web interface for MySQL and M…   784       [OK]       
circleci/mysql                  MySQL is a widely used, open-source relation…   29                   
bitnami/mysql                   Bitnami MySQL Docker Image                      83                   [OK]

#返回结果注释
NAME			#镜像名
DESCRIPTION		#镜像描述
STARS			#STARS数
OFFICIAL		#是否为官方发布
AUTOMATED		#是否自动构建

#可选项
Options:
  -f, --filter filter   #根据条件过滤
</code></pre>
<h3 id='拉取镜像'>拉取镜像</h3>
<blockquote><p>docker pull [镜像名] [:tag]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>Using default tag: latest				#如果不写tag，默认最新版本
latest: Pulling from library/mysql
328ba678bf27: Pull complete 
f3f5ff008d73: Pull complete 
dd7054d6d0c7: Pull complete 
70b5d4e8750e: Pull complete 
cdc4a7b43bdd: Pull complete 
a0608f8959e0: Pull complete 
5823e721608f: Pull complete 
a564ada930a9: Pull complete 
539565d00e89: Pull complete 
a11a06843fd5: Pull complete 
92f6d4aa041d: Pull complete 
Digest: sha256:a43f6e7e7f3a5e5b90f857fbed4e3103ece771b19f0f75880f767cf66bbb6577
Status: Downloaded newer image for mysql:latest
docker.io/library/mysql:latest			#真实地址

#返回结果注释
Using default tag: latest		#默认使用最新版本
</code></pre>
<h3 id='删除镜像'>删除镜像</h3>
<blockquote><p>docker rmi -f [镜像名或ID]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>docker rmi -f [镜像ID] [镜像ID] [镜像ID]		#删除多个镜像
</code></pre>
<h3 id='查看镜像历史'>查看镜像历史</h3>
<blockquote><p>docker history [镜像ID]</p>
</blockquote>
<h2 id='容器命令'>容器命令</h2>
<p><strong>下载一个centos镜像进行测试</strong></p>
<pre><code class='language-shell' lang='shell'>docker pull centos
</code></pre>
<p><strong>新建容器并启动</strong></p>
<h3 id='运行容器'>运行容器</h3>
<blockquote><p>docker run [参数] [镜像名]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>docker run [参数] image

#参数说明
--name=&quot;Name&quot;		容器的名字
-d					后台运行
-it					交互方式运行，进入容器查看内容
-p(小写)			   指定容器的端口 -p 8080:8080
	-p 主机端端口:容器端口
	-p 容器端口
-P(大写)			   随机指定端口映射
</code></pre>
<pre><code class='language-shell' lang='shell'>docker run -it centos /bin/bash		#启动一个centos，并进入容器环境
exit								#退出容器
</code></pre>
<h3 id='显示当前运行的容器'>显示当前运行的容器</h3>
<blockquote><p>docker ps [参数]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES

#返回结果注释   当前没有容器在运行
CONTAINER ID		容器ID
IMAGE				使用的镜像
COMMAND				启动容器时运行的命令
CREATED				容器的创建时间
STATUS				容器状态
	有其中状态：
		created		（已创建）
		restarting	（重启中）
		running		（运行中）
		removing	（迁移中）
		paused		（暂停）
		exited		（停止）
		dead		（死亡）
PORTS				容器的端口信息和使用的连接类型（tcp\udp）
NAMES				自动分配的容器名称

#可选参数
-a 					显示所有的容器，包括未运行的。
-n 					列出最近创建的n个容器。
-q 					静默模式，只显示容器编号。
</code></pre>
<h3 id='退出容器'>退出容器</h3>
<blockquote><p>exit			#退出并停止</p>
<p>Ctrl + P + Q	#退出不停止</p>
</blockquote>
<h3 id='删除容器'>删除容器</h3>
<blockquote><p>docker rm [容器ID]				#删除指定容器</p>
<p>docker rm -f $(docker ps -aq)	#删除所有容器</p>
</blockquote>
<h3 id='启动容器'>启动容器</h3>
<blockquote><p>docker start [容器id]</p>
</blockquote>
<h3 id='重启容器'>重启容器</h3>
<blockquote><p>docker restart [容器id]</p>
</blockquote>
<h3 id='停止容器'>停止容器</h3>
<blockquote><p>docker stop [容器id]</p>
</blockquote>
<h3 id='强制停止'>强制停止</h3>
<blockquote><p>docker kill [容器id]</p>
</blockquote>
<h3 id='后台启动容器'>后台启动容器</h3>
<blockquote><p>docker run -d [镜像名]</p>
</blockquote>
<p>使用docker run -d命令启动容器必须要有一个前台进程一直运行</p>
<h3 id='日志'>日志</h3>
<blockquote><p>docker logs [参数] [容器名或ID]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>#参数
OPTIONS：

-f			跟踪日志输出
--since		显示某个开始时间的所有日志
-t			显示时间戳
--tail		仅列出最新N条容器日志
</code></pre>
<h3 id='查看容器中的进程'>查看容器中的进程</h3>
<blockquote><p>docker top [容器ID]</p>
</blockquote>
<h3 id='进入正在运行的容器'>进入正在运行的容器</h3>
<p>开启新的终端：</p>
<blockquote><p>docker exec [参数] [容器ID]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>OPTIONS说明：

-d			分离模式: 在后台运行
-i			即使没有附加也保持STDIN 打开
-t			分配一个伪终端
</code></pre>
<p>进入当前运行的终端，不开启新进程</p>
<blockquote><p>docker attach [容器ID]</p>
</blockquote>
<h3 id='从容器内拷贝文件到主机'>从容器内拷贝文件到主机</h3>
<blockquote><p>docker cp [参数] 容器ID:文件地址 主机文件地址</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>#实例 从容器复制文件到主机
docker cp 13e0bf84c8cc:/root/cptest /root
</code></pre>
<h3 id='从主机复制文件到容器'>从主机复制文件到容器</h3>
<blockquote><p>docker cp [参数] 主机文件地址 容器ID：文件地址</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>#实例 从主机复制文件到容器
docker cp /root/testcp 13e0bf84c8cc:/root/
</code></pre>
<h2 id='常用命令小结'>常用命令小结</h2>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\image-20230424115903107.png" referrerpolicy="no-referrer" alt="image-20230424115903107"></p>
<p>&nbsp;</p>
<h1 id='docker部署nginx'>Docker部署Nginx</h1>
<hr />
<pre><code class='language-shell' lang='shell'>1.搜索Nginx镜像
[root@HW-GDW ~]# docker search nginx
NAME                                      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
nginx                                     Official build of Nginx.                        18417     [OK]       
unit                                      Official build of NGINX Unit: a polyglot app…   0         [OK]       
bitnami/nginx                             Bitnami nginx Docker Image                      159                  [OK]
bitnami/nginx-ingress-controller          Bitnami Docker Image for NGINX Ingress Contr…   25                   [OK]
ubuntu/nginx                              Nginx, a high-performance reverse proxy &amp; we…   86                   
kasmweb/nginx                             An Nginx image based off nginx:alpine and in…   6                    

2.拉取镜像
[root@HW-GDW ~]# docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
26c5c85e47da: Pull complete 
4f3256bdf66b: Pull complete 
2019c71d5655: Pull complete 
8c767bdbc9ae: Pull complete 
78e14bb05fd3: Pull complete 
75576236abf5: Pull complete 
Digest: sha256:63b44e8ddb83d5dd8020327c1f40436e37a6fffd3ef2498a6204df23be6e7e94
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest

3.启动容器 后台运行 容器名字为nginx001 主机端口1122映射容器端口80
[root@HW-GDW ~]# docker run -d --name nginx001 -p 1122:80 nginx

4.测试
[root@HW-GDW ~]# curl 127.0.0.1:1122
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

5.进入容器
[root@HW-GDW ~]# docker exec -it nginx001 /bin/bash

6.查找nginx目录
root@c52714218fd2:/# whereis nginx
nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx
</code></pre>
<p>&nbsp;</p>
<h1 id='docker部署tomcat'>Docker部署Tomcat</h1>
<hr />
<pre><code class='language-shell' lang='shell'>1.搜索镜像
[root@HW-GDW ~]# docker search tomcat
NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
tomcat                            Apache Tomcat is an open source implementati…   3526      [OK]       
tomee                             Apache TomEE is an all-Apache Java EE certif…   106       [OK]       
bitnami/tomcat                    Bitnami Tomcat Docker Image                     48                   [OK]
bitnamicharts/tomcat                                                              0                    
secoresearch/tomcat-varnish       Tomcat and Varnish 5.0                          0                    [OK]

2.拉取镜像
[root@HW-GDW ~]# docker pull tomcat:9.0
9.0: Pulling from library/tomcat
74ac377868f8: Pull complete 
a182a611d05b: Pull complete 
ad4fe29a3001: Pull complete 
9d52462c5181: Pull complete 
ac04a5bb8dd2: Pull complete 
98c436ff99dd: Pull complete 
ba6402d8fad2: Pull complete 
Digest: sha256:924f7ad52850e319a39f8c2e59da92337b175a6c6cc53e9bf6e8ae19fe88a321
Status: Downloaded newer image for tomcat:9.0
docker.io/library/tomcat:9.0

3.创建容器并启动
[root@HW-GDW ~]# docker run -d -p 2233:8080 --name tomcat001 tomcat:9.0
41fefc7010aee0594d0b6dbc07ee2bff893e7837283e0f4d0f1e5c22bcfee688

4.进入测试
root@41fefc7010ae:/usr/local/tomcat# ls
bin           conf             lib      logs            NOTICE     RELEASE-NOTES  temp     webapps.dist
BUILDING.txt  CONTRIBUTING.md  LICENSE  native-jni-lib  README.md  RUNNING.txt    webapps  work
</code></pre>
<p>&nbsp;</p>
<h1 id='可视化界面'>可视化界面</h1>
<hr />
<ul>
<li>portainer(暂时使用)</li>

</ul>
<pre><code class='language-shell' lang='shell'>#安装
docker run -d -p 8088:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
</code></pre>
<ul>
<li>Rancher(CI/DI时使用)</li>

</ul>
<p>&nbsp;</p>
<h1 id='docker镜像'>Docker镜像</h1>
<hr />
<h2 id='镜像是什么'>镜像是什么</h2>
<p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，包含某个软件的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<p>所有的应用，直接打包docker镜像就可以跑起来</p>
<p>如何获得镜像：</p>
<ul>
<li>远程仓库</li>
<li>自己制作DockerFile</li>

</ul>
<h2 id='docker镜像加载原理'>Docker镜像加载原理</h2>
<blockquote><p>UnionFS(联合文件系统)</p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同事可以将不同目录挂在到同一个虚拟文件系统下。</p>
<p>Union文件系统是Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像，可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<blockquote><p>Docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上是由一层一层的文件系统组成，这种层级的文件系统叫做UnionFS</p>
<p>bootfs(boot file system)主要包含bootloade和kernel，bootloader主要是引导加载kernel，Linux刚启动是会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs，这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核，当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs</p>
<p>rootfs(root flie system)在bootfs之上，包含的就是典型Linux系统中的/dev /proc /bin /etc等标准目录和文件，rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\image-20230424171639552.png" referrerpolicy="no-referrer" alt="image-20230424171639552"></p>
<p>&nbsp;</p>
<h2 id='commit镜像'>commit镜像</h2>
<p>如何提交一个自己的镜像</p>
<h3 id='提交镜像'>提交镜像</h3>
<blockquote><p>docker commit [参数] [容器ID] [目标镜像名]:[TAG]</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>#例子
docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器ID 目标镜像名:[TAG]
</code></pre>
<p>&nbsp;</p>
<h1 id='容器数据卷'>容器数据卷</h1>
<hr />
<h2 id='为什么需要容器数据卷'>为什么需要容器数据卷</h2>
<p>docker将应用和环境打包为一个镜像。</p>
<p>如果数据都存储在容器当中，当容器被删除之后，数据也会丢失。<strong>数据需要单独保存</strong>。</p>
<p>Docker提供了一种在容器之间数据共享的技术，Docker容器中产生的数据可以同步到主机。</p>
<h2 id='什么是容器数据卷'>什么是容器数据卷</h2>
<p>容器数据卷技术就是将容器内的目录挂在到主机上。</p>
<p>容器和主机数据共享，容器与容器数据共享。</p>
<h2 id='使用数据卷'>使用数据卷</h2>
<blockquote><p>方式一：直接使用命令挂载 -v</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>docker run -it -v [主机内的目录]:[容器内的目录]
</code></pre>
<h2 id='mysql数据同步'>MySQL数据同步</h2>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW home]# docker run -d -p 1122:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql001 mysql:5.7

-d		后台启动
-p		设置端口映射
-v		设置文件映射
-e		设置参数
--name	设置容器名称
</code></pre>
<h2 id='具名和匿名挂载'>具名和匿名挂载</h2>
<p>匿名挂载</p>
<pre><code class='language-shell' lang='shell'>#只指定容器内地址
[root@HW-GDW /]# docker run -d -P -v /etc/nginx nginx
33cb29e88f37ee251586fcbdc432c9b3e0c7a015428f78e0c33afe819c64bb9a

#查看所有卷的情况
[root@HW-GDW /]# docker volume ls
DRIVER    VOLUME NAME
#名字为随机字符串的为匿名挂在的卷
local     7f424363a08b501ceff0984cf13862ff7167a9d40d06673e0ad49bf632c3916e
local     15bc376bf6406af67cd2ef25dec43ee6b46394024a35f66c96e5516df9ae3c8e
local     096d888fe826710e9e85a0fff20079823ede42fada20f164772beda184ca7b8b
local     a14c3b01eb1dbe8d6e30494f595fda607a12afec141c88623ddf3975a7b7028d
local     fdbcd4ba43b8bfddaa1123bdfb9978c12ad0cbebc125f1c980e45a662541e09a
</code></pre>
<p>具名挂载</p>
<pre><code class='language-shell' lang='shell'>#指定容器内地址时设置卷名
[root@HW-GDW /]# docker run -d -P -v juming-nginx:/etc/nginx --name nginx002 nginx
772834a38b2adba24a577285f28f1e6b6a7815120ce32c78af642e3edb34e979

#查看所有卷
[root@HW-GDW /]# docker volume ls
DRIVER    VOLUME NAME
local     7f424363a08b501ceff0984cf13862ff7167a9d40d06673e0ad49bf632c3916e
local     15bc376bf6406af67cd2ef25dec43ee6b46394024a35f66c96e5516df9ae3c8e
local     096d888fe826710e9e85a0fff20079823ede42fada20f164772beda184ca7b8b
local     a14c3b01eb1dbe8d6e30494f595fda607a12afec141c88623ddf3975a7b7028d
local     fdbcd4ba43b8bfddaa1123bdfb9978c12ad0cbebc125f1c980e45a662541e09a
#名字
local     juming-nginx

#查看这个卷的具体信息
[root@HW-GDW /]# docker volume inspect juming-nginx
[
    {
        &quot;CreatedAt&quot;: &quot;2023-04-25T11:36:15+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: null,
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/juming-nginx/_data&quot;,
        &quot;Name&quot;: &quot;juming-nginx&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<p>所有docker容器的卷，没有指定主机目录的情况下，都是挂载在/var/lib/docker/volumes下</p>
<pre><code class='language-shell' lang='shell'>#推荐使用具名挂载
-v 容器内路径		#匿名挂在
-v 卷名:容器内路径	   #具名挂载
-v 主机路径:容器内路径 #指定路径挂载
</code></pre>
<h3 id='扩展读写权限）'>扩展（读写权限）</h3>
<pre><code class='language-shell' lang='shell'>#通过-v [容器内路径] ro rw 修改权限
ro	readonly	#只读
re	readwrite	#可读可写

docker run -d -P --name nginx002 -v juming-nginx:/etc/nginx:ro nginx
docker run -d -P --name nginx002 -v juming-nginx:/etc/nginx:rw nginx
</code></pre>
<p>&nbsp;</p>
<h3 id='通过dockerfile来挂载'>通过Dockerfile来挂载</h3>
<p>生成一个镜像，在创建容器的时候挂载</p>
<pre><code class='language-shell' lang='shell'>#创建一个脚本，通过这个脚本可以生成镜像

#书写脚本
	#以centos为基底
FROM centos
	#挂载两个卷
VOLIME [&quot;volume01&quot;, &quot;volume02&quot;]
	#CMD指令 挂载结束后输出
CMD echo &quot;------end------&quot;
	#使用bash运行
CMD /bin/bash

#通过Docker运行脚本
[root@HW-GDW docker-test-volume]# docker build -f ./dockerfile1 -t gdw/centos:1.0 .
[+] Building 0.0s (5/5) FINISHED                                                                                   
 =&gt; [internal] load build definition from dockerfile1                                                         0.0s
 =&gt; =&gt; transferring dockerfile: 126B                                                                          0.0s
 =&gt; [internal] load .dockerignore                                                                             0.0s
 =&gt; =&gt; transferring context: 2B                                                                               0.0s
 =&gt; [internal] load metadata for docker.io/library/centos:latest                                              0.0s
 =&gt; [1/1] FROM docker.io/library/centos                                                                       0.0s
 =&gt; exporting to image                                                                                        0.0s
 =&gt; =&gt; exporting layers                                                                                       0.0s
 =&gt; =&gt; writing image sha256:f4694dbeb2ad07f0d9b3eb4ed0cbbd5b4a6497830854cd072c72709e89609a86                  0.0s
 =&gt; =&gt; naming to docker.io/gdw/centos:1.0                                                                     0.0s

#通过镜像创建容器
[root@HW-GDW /]# docker run -it f4694dbeb2ad /bin/bash

#查看目录
[root@a6f55952bb07 /]# ls -l
total 56
lrwxrwxrwx  1 root root    7 Nov  3  2020 bin -&gt; usr/bin
drwxr-xr-x  5 root root  360 Apr 25 06:37 dev
drwxr-xr-x  1 root root 4096 Apr 25 06:37 etc
drwxr-xr-x  2 root root 4096 Nov  3  2020 home
lrwxrwxrwx  1 root root    7 Nov  3  2020 lib -&gt; usr/lib
lrwxrwxrwx  1 root root    9 Nov  3  2020 lib64 -&gt; usr/lib64
drwx------  2 root root 4096 Sep 15  2021 lost+found
drwxr-xr-x  2 root root 4096 Nov  3  2020 media
drwxr-xr-x  2 root root 4096 Nov  3  2020 mnt
drwxr-xr-x  2 root root 4096 Nov  3  2020 opt
dr-xr-xr-x 99 root root    0 Apr 25 06:37 proc
dr-xr-x---  2 root root 4096 Sep 15  2021 root
drwxr-xr-x 11 root root 4096 Sep 15  2021 run
lrwxrwxrwx  1 root root    8 Nov  3  2020 sbin -&gt; usr/sbin
drwxr-xr-x  2 root root 4096 Nov  3  2020 srv
dr-xr-xr-x 13 root root    0 Apr 25 06:37 sys
drwxrwxrwt  7 root root 4096 Sep 15  2021 tmp
drwxr-xr-x 12 root root 4096 Sep 15  2021 usr
drwxr-xr-x 20 root root 4096 Sep 15  2021 var
drwxr-xr-x  2 root root 4096 Apr 25 06:37 volume01
drwxr-xr-x  2 root root 4096 Apr 25 06:37 volume02

#查看挂载
[root@HW-GDW /]# cd /var/lib/docker/volumes
[root@HW-GDW volumes]# ls
096d888fe826710e9e85a0fff20079823ede42fada20f164772beda184ca7b8b
15bc376bf6406af67cd2ef25dec43ee6b46394024a35f66c96e5516df9ae3c8e
7f424363a08b501ceff0984cf13862ff7167a9d40d06673e0ad49bf632c3916e
a14c3b01eb1dbe8d6e30494f595fda607a12afec141c88623ddf3975a7b7028d
backingFsBlockDev
f3afb16acb2aeedabb1dff45418465c79557963be81932838103b1813dcc34d9
fd226837698a35aeed4d4668c94bf1dfb1fd6f418624974c3378d06f19f19946
fdbcd4ba43b8bfddaa1123bdfb9978c12ad0cbebc125f1c980e45a662541e09a
juming-nginx
metadata.db
[root@HW-GDW _data]# docker volume inspect f3afb16acb2aeedabb1dff45418465c79557963be81932838103b1813dcc34d9
[
    {
        &quot;CreatedAt&quot;: &quot;2023-04-25T14:37:08+08:00&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {
            &quot;com.docker.volume.anonymous&quot;: &quot;&quot;
        },
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/f3afb16acb2aeedabb1dff45418465c79557963be81932838103b1813dcc34d9/_data&quot;,
        &quot;Name&quot;: &quot;f3afb16acb2aeedabb1dff45418465c79557963be81932838103b1813dcc34d9&quot;,
        &quot;Options&quot;: null,
        &quot;Scope&quot;: &quot;local&quot;
    }
]
</code></pre>
<h2 id='数据卷容器继承'>数据卷容器(继承)</h2>
<p>多个容器共享数据</p>
<pre><code class='language-shell' lang='shell'>#开启一个容器
[root@HW-GDW _data]# docker run -it --name docker01 f4694dbeb2ad /bin/bash

#开启另一个容器，继承第一个容器的挂载
[root@HW-GDW ~]# docker run -it --name docker02 --volumes-from docker01 f4694dbeb2ad /bin/bash

#此时容器和主机中的volume01 和 volume02文件夹是共享的
</code></pre>
<p>&nbsp;</p>
<h1 id='dockerfile'>DockerFile</h1>
<hr />
<p>dockerfile是用来构建docker镜像的（命令参数脚本）</p>
<h2 id='dockerfile使用步骤'>DockerFile使用步骤</h2>
<p><strong>构建步骤：</strong></p>
<ol start='' >
<li>编写一个dockerfile文件</li>
<li>使用docker build指令 构建一个镜像</li>
<li>docker run 创建容器</li>
<li>docker push 推送镜像（发送到DockerHub、阿里云镜像仓库）</li>

</ol>
<h2 id='dockerfile构建过程'>DockerFile构建过程</h2>
<p><strong>基础知识：</strong></p>
<ol start='' >
<li>每个关键字（指令）都必须是大写字母</li>
<li>执行从上到下</li>
<li>#表示注释</li>
<li>每一个指令都会创建提交一个新层</li>

</ol>
<p>Dockerfile是面向开发的，以后要发布项目，做镜像，需要编写dockerfile文件</p>
<p>Docker逐渐成为企业交付的标准</p>
<h2 id='dockerfile指令'>DockerFile指令</h2>
<ol start='' >
<li>FROM</li>

</ol>
<blockquote><p>FROM [镜像]</p>
<p>FROM [镜像]:[tag]</p>
</blockquote>
<p>FROM指令，提供基础镜像</p>
<ol start='2' >
<li>MAINTAINER</li>

</ol>
<blockquote><p>MAINTAINER [名字+邮箱]</p>
</blockquote>
<p>MAINTAINER指令，指定作者</p>
<ol start='3' >
<li>RUN</li>

</ol>
<blockquote><p>RUN [命令行命令]</p>
<p>RUN [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;]</p>
</blockquote>
<p>用于执行后面跟着的命令行命令</p>
<ol start='4' >
<li>ADD</li>

</ol>
<blockquote><p>ADD [源路径1] [源路径2]... [目标路径]</p>
</blockquote>
<p>用于从上下文中复制文件或者目录到容器中的指定路径，遇到压缩格式的文件会自动解压</p>
<ol start='5' >
<li>WORKDIR</li>

</ol>
<blockquote><p>WORKDIR [工作目录路径]</p>
</blockquote>
<p>用于指定工作目录</p>
<ol start='6' >
<li>VOLUME</li>

</ol>
<blockquote><p>VOLUME [&quot;路径1&quot;,&quot;路径2&quot;...]</p>
</blockquote>
<p>设置挂载卷</p>
<ol start='7' >
<li>EXPOSE</li>

</ol>
<blockquote><p>EXPOSE [端口1] [端口2]</p>
</blockquote>
<p>暴露端口</p>
<ol start='8' >
<li>CMD</li>

</ol>
<blockquote><p>CMD [指令]</p>
</blockquote>
<p>指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代</p>
<ol start='9' >
<li>ENTRYPOINT</li>

</ol>
<blockquote><p>ENTRYPOINT [指令]</p>
</blockquote>
<p>指定这个容器启动的时候要运行的命令，可以追加命令</p>
<ol start='10' >
<li>ONBUILD</li>

</ol>
<blockquote><p>ONBUILD [指令]</p>
</blockquote>
<p>当有容器继承时触发</p>
<ol start='11' >
<li>COPY</li>

</ol>
<blockquote><p>COPY [源路径1] [源路径2]... [目标路径]</p>
</blockquote>
<p>和ADD类似，但是不解压</p>
<ol start='12' >
<li>ENV</li>

</ol>
<blockquote><p>ENV [环境名] [环境路径]</p>
</blockquote>
<h2 id='构建censtos'>构建censtos</h2>
<ol start='' >
<li>编写Dockerfile文件</li>

</ol>
<pre><code class='language-shell' lang='shell'>FROM centos:7
  
MAINTAINER GDW&lt;123456@qwe.com&gt;

ENV MYPATH /usr/local

WORKDIR $MYPATH

RUN yum -y install vim
RUN yum -y install net-tools

EXPOSE 80 
         
CMD echo @MYPATH
         
CMD echo &quot;------end------&quot;
</code></pre>
<ol start='2' >
<li>构建镜像</li>

</ol>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW home]# docker build -f mydockerfile -t mycentos:0.1 .
[+] Building 66.1s (9/9) FINISHED                                                                                  
 =&gt; [internal] load build definition from mydockerfile                                                        0.0s
 =&gt; =&gt; transferring dockerfile: 260B                                                                          0.0s
 =&gt; [internal] load .dockerignore                                                                             0.0s
 =&gt; =&gt; transferring context: 2B                                                                               0.0s
 =&gt; [internal] load metadata for docker.io/library/centos:7                                                   3.2s
 =&gt; [1/5] FROM docker.io/library/centos:7@sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d64874  4.2s
 =&gt; =&gt; resolve docker.io/library/centos:7@sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d64874  0.0s
 =&gt; =&gt; sha256:be65f488b7764ad3638f236b7b515b3678369a5124c47b8d32916d6487418ea4 1.20kB / 1.20kB                0.0s
 =&gt; =&gt; sha256:dead07b4d8ed7e29e98de0f4504d87e8880d4347859d839686a31da35a3b532f 529B / 529B                    0.0s
 =&gt; =&gt; sha256:eeb6ee3f44bd0b5103bb561b4c16bcb82328cfe5809ab675bb17ab3a16c517c9 2.75kB / 2.75kB                0.0s
 =&gt; =&gt; sha256:2d473b07cdd5f0912cd6f1a703352c82b512407db6b05b43f2553732b55df3bc 76.10MB / 76.10MB              0.9s
 =&gt; =&gt; extracting sha256:2d473b07cdd5f0912cd6f1a703352c82b512407db6b05b43f2553732b55df3bc                     3.0s
 =&gt; [2/5] WORKDIR /usr/local                                                                                  0.9s
 =&gt; [3/5] RUN yum -y install vim                                                                             48.8s
 =&gt; [4/5] RUN yum -y install vim                                                                              2.4s 
 =&gt; [5/5] RUN yum -y install net-tools                                                                        2.8s 
 =&gt; exporting to image                                                                                        3.7s 
 =&gt; =&gt; exporting layers                                                                                       3.7s 
 =&gt; =&gt; writing image sha256:8c9beff4ed23e72a34748576a564f8e77e3b7d43545ee27c612e36c5d78244f3                  0.0s 
 =&gt; =&gt; naming to docker.io/library/mycentos:0.1       
</code></pre>
<p>&nbsp;</p>
<blockquote><p>CMD 和 ENTRYPOINT 区别</p>
</blockquote>
<pre><code class='language-shell' lang='shell'>CMD				# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代
ENTRYPOINT		# 指定这个容器启动的时候要运行的命令，可以追加命令
</code></pre>
<h3 id='cmd'>CMD</h3>
<p>dockerfile:</p>
<pre><code class='language-dockerfile' lang='dockerfile'>FROM centos:7
CMD [&quot;ls&quot;,&quot;-a&quot;]
</code></pre>
<p>构建镜像：</p>
<pre><code class='language-shell' lang='shell'>docker build -f dockerfile_CMD_test -t cmdtest .
[+] Building 0.0s (5/5) FINISHED                                                                                                                       
 =&gt; [internal] load build definition from dockerfile_CMD_test                                                           0.0s
 =&gt; =&gt; transferring dockerfile: 76B                                                                                     0.0s
 =&gt; [internal] load .dockerignore																                        0.0s
 =&gt; =&gt; transferring context: 2B                                                                                         0.0s
 =&gt; [internal] load metadata for docker.io/library/centos:7                                                             0.0s
 =&gt; CACHED [1/1] FROM docker.io/library/centos:7                                                                        0.0s
 =&gt; exporting to image                                                                                                  0.0s
 =&gt; =&gt; exporting layers                                                                                                 0.0s
 =&gt; =&gt; writing image sha256:7e1284fbaec0864f323e3112169c0904ba67ad4fce16bfb7a23d1e7e3386f0e4                            0.0s
 =&gt; =&gt; naming to docker.io/library/cmdtest     
</code></pre>
<p>启动镜像：</p>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW home]# docker run 7e1284fbaec0
.
..
.dockerenv
anaconda-post.log
bin
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

#CMD指定的命令只能覆盖，不能追加
# 替换成-l的时候，系统中没有-l这个命令，报错
[root@HW-GDW home]# docker run 7e1284fbaec0 -l
docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.

#必须写全命令，替换掉原来CMD指定的命令
[root@HW-GDW home]# docker run 7e1284fbaec0 ls -l
total 56
-rw-r--r--  1 root root 12114 Nov 13  2020 anaconda-post.log
lrwxrwxrwx  1 root root     7 Nov 13  2020 bin -&gt; usr/bin
drwxr-xr-x  5 root root   340 May 19 00:42 dev
drwxr-xr-x  1 root root  4096 May 19 00:42 etc
drwxr-xr-x  2 root root  4096 Apr 11  2018 home
lrwxrwxrwx  1 root root     7 Nov 13  2020 lib -&gt; usr/lib
lrwxrwxrwx  1 root root     9 Nov 13  2020 lib64 -&gt; usr/lib64
drwxr-xr-x  2 root root  4096 Apr 11  2018 media
drwxr-xr-x  2 root root  4096 Apr 11  2018 mnt
drwxr-xr-x  2 root root  4096 Apr 11  2018 opt
dr-xr-xr-x 98 root root     0 May 19 00:42 proc
dr-xr-x---  2 root root  4096 Nov 13  2020 root
drwxr-xr-x 11 root root  4096 Nov 13  2020 run
lrwxrwxrwx  1 root root     8 Nov 13  2020 sbin -&gt; usr/sbin
drwxr-xr-x  2 root root  4096 Apr 11  2018 srv
dr-xr-xr-x 13 root root     0 May 19 00:42 sys
drwxrwxrwt  7 root root  4096 Nov 13  2020 tmp
drwxr-xr-x 13 root root  4096 Nov 13  2020 usr
drwxr-xr-x 18 root root  4096 Nov 13  2020 var
</code></pre>
<h3 id='entrypoint'>ENTRYPOINT</h3>
<p>dockerfile:</p>
<pre><code class='language-dockerfile' lang='dockerfile'>FROM centso:7
ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]
</code></pre>
<p>构建镜像：</p>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW home]# docker build -f dockerfile_ENTRYPOINT_test -t entrypointtest .
[+] Building 0.0s (5/5) FINISHED                                                                                                                       
 =&gt; [internal] load build definition from dockerfile_ENTRYPOINT_test						                     0.0s
 =&gt; =&gt; transferring dockerfile: 89B            															          0.0s
 =&gt; [internal] load .dockerignore           															           0.0s
 =&gt; =&gt; transferring context: 2B             															         0.0s
 =&gt; [internal] load metadata for docker.io/library/centos:7    									                  0.0s
 =&gt; CACHED [1/1] FROM docker.io/library/centos:7            											         0.0s
 =&gt; exporting to image            																		         0.0s
 =&gt; =&gt; exporting layers        																		              0.0s
 =&gt; =&gt; writing image sha256:bdfd91bddc73e66972305ae19ffa197dce5391af7afeb018170fbecab2c56705                     0.0s
 =&gt; =&gt; naming to docker.io/library/entrypointtest   										                   0.0s
</code></pre>
<p>启动镜像：</p>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW home]# docker run 80571210ff3a
.
..
.dockerenv
anaconda-post.log
bin
dev
etc
home
lib
lib64
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

# ENTRYPOINT 不替换命令 可追加命令
[root@HW-GDW home]# docker run 80571210ff3a -l
total 64
drwxr-xr-x  1 root root  4096 May 19 02:57 .
drwxr-xr-x  1 root root  4096 May 19 02:57 ..
-rwxr-xr-x  1 root root     0 May 19 02:57 .dockerenv
-rw-r--r--  1 root root 12114 Nov 13  2020 anaconda-post.log
lrwxrwxrwx  1 root root     7 Nov 13  2020 bin -&gt; usr/bin
drwxr-xr-x  5 root root   340 May 19 02:57 dev
drwxr-xr-x  1 root root  4096 May 19 02:57 etc
drwxr-xr-x  2 root root  4096 Apr 11  2018 home
lrwxrwxrwx  1 root root     7 Nov 13  2020 lib -&gt; usr/lib
lrwxrwxrwx  1 root root     9 Nov 13  2020 lib64 -&gt; usr/lib64
drwxr-xr-x  2 root root  4096 Apr 11  2018 media
drwxr-xr-x  2 root root  4096 Apr 11  2018 mnt
drwxr-xr-x  2 root root  4096 Apr 11  2018 opt
dr-xr-xr-x 99 root root     0 May 19 02:57 proc
dr-xr-x---  2 root root  4096 Nov 13  2020 root
drwxr-xr-x 11 root root  4096 Nov 13  2020 run
lrwxrwxrwx  1 root root     8 Nov 13  2020 sbin -&gt; usr/sbin
drwxr-xr-x  2 root root  4096 Apr 11  2018 srv
dr-xr-xr-x 13 root root     0 May 19 02:57 sys
drwxrwxrwt  7 root root  4096 Nov 13  2020 tmp
drwxr-xr-x 13 root root  4096 Nov 13  2020 usr
drwxr-xr-x 18 root root  4096 Nov 13  2020 var
</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id='尚硅谷部分'>尚硅谷部分</h1>
<h2 id='数据卷'>数据卷</h2>
<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能绕过Union File System提供的一些用于持续存储或共享数据的特性：</p>
<p>卷的设计目的就是<strong>数据持久化</strong>，完全独立于容器的生存周期，因此Docker不会再容器被删除时删除其挂载的数据卷</p>
<p>特点：</p>
<ul>
<li>数据卷可以在容器之间共享或者重用</li>
<li>卷中的更改可以直接实时生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一致持续到没有容器使用它为止</li>

</ul>
<p>运行一个带有容器卷存储功能的实例：</p>
<blockquote><p>docker run -it --privileged=true -v 宿主机绝对路径：容器内目录绝对路径[rw | ro]镜像名</p>
</blockquote>
<p>权限：</p>
<ul>
<li>rw : 读写</li>
<li>ro : 只读（宿主机可以写入内容，可以同步给容器内，容器只能读取） </li>

</ul>
<p>可以使用以下命令查看容器绑定的数据卷：</p>
<blockquote><p>docker inspect</p>
</blockquote>
<p>容器卷的继承：</p>
<pre><code class='language-shell' lang='shell'>#启动一个容器
dicker run -it --privileged=true /tmp/test:/tem/docker --name u1 ubuntu /bin/bash

#使用 --volumes-from 继承 u1的容器卷映射
docker run -it --privileged=true --volumes-from u1 --name u2 ubuntu
</code></pre>
<p>&nbsp;</p>
<h2 id='所有指令示意图'>所有指令示意图</h2>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\image-20230522161217008.png" referrerpolicy="no-referrer" alt="image-20230522161217008"></p>
<p>&nbsp;</p>
<h2 id='docker与微服务'>Docker与微服务</h2>
<h3 id='mysql主从复制'>MySQL主从复制</h3>
<h4 id='1新建主服务器容器实例-port3307'>1.新建主服务器容器实例 port:3307</h4>
<pre><code class='language-shell' lang='shell'>docker run -p 3307:3306 --name mysql-main \
-v /home/mysql-main/log:/var/log/mysql \
-v /home/mysql-main/data:/var/lib/mysql \
-v /home/mysql-main/conf:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.33
</code></pre>
<h4 id='2进入homemysql-mainconf目录下新建mycnf'>2.进入/home/mysql-main/conf目录下新建my.cnf</h4>
<pre><code class='language-shell' lang='shell'>vim my.cnf
</code></pre>
<pre><code class='language-shell' lang='shell'>[mysqld]
## 设置server_id，同一局域网中需要唯一
server_id=101
## 指定不需要同步的数据库名称
binlog-ignore-db=mysql
## 开启二进制日志功能
log-bin=mall-mysql-bin
## 设置二进制日志使用内存大小（事务）
binlog_cache_size=1M
## 设置使用的二进制日志格式（mixed,statement,row）
binlog_format=mixed
## 二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062
</code></pre>
<h4 id='3重启main实例'>3.重启main实例</h4>
<pre><code class='language-shell' lang='shell'>docker restart mysql-main
</code></pre>
<h4 id='4进入mysql-main容器'>4.进入mysql-main容器</h4>
<pre><code class='language-shell' lang='shell'>docker exec -it mysql-main /bin/bash
</code></pre>
<h4 id='5创建用户'>5.创建用户</h4>
<pre><code class='language-sql' lang='sql'>mysql&gt; CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
</code></pre>
<h4 id='6赋予权限用于数据同步'>6.赋予权限，用于数据同步</h4>
<pre><code class='language-sql' lang='sql'>mysql&gt; GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;slave&#39;@&#39;%&#39;;
</code></pre>
<h4 id='7新建从服务器容器实例-port3308'>7.新建从服务器容器实例 port:3308</h4>
<pre><code class='language-shell' lang='shell'>docker run -p 3308:3306 --name mysql-slave \
-v /home/mysql-slave/log:/var/log/mysql \
-v /home/mysql-slave/data:/var/lib/mysql \
-v /home/mysql-slave/conf:/etc/mysql/conf.d \
-e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.33
</code></pre>
<h4 id='8进入homemysql-slaveconf目录下新建mycnf'>8.进入/home/mysql-slave/conf目录下新建my.cnf</h4>
<pre><code class='language-shell' lang='shell'>[mysqld]
## 设置server_id，同一局域网中需要唯一
server_id=102
## 指定不需要同步的数据库名称
binlog-ignore-db=mysql  
## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用
log-bin=mall-mysql-slave1-bin  
## 设置二进制日志使用内存大小（事务）
binlog_cache_size=1M  
## 设置使用的二进制日志格式（mixed,statement,row）
binlog_format=mixed  
## 二进制日志过期清理时间。默认值为0，表示不自动清理。
expire_logs_days=7  
## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。
## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致
slave_skip_errors=1062  
## relay_log配置中继日志
relay_log=mall-mysql-relay-bin  
## log_slave_updates表示slave将复制事件写进自己的二进制日志
log_slave_updates=1  
## slave设置为只读（具有super权限的用户除外）
read_only=1
</code></pre>
<h4 id='9重启mysql-slave实例'>9.重启mysql-slave实例</h4>
<pre><code class='language-shell' lang='shell'>docker restart mysql-slave
</code></pre>
<h4 id='10在主数据库中查看同步状态'>10.在主数据库中查看同步状态</h4>
<pre><code class='language-sql' lang='sql'>mysql&gt; show master status
</code></pre>
<h4 id='11在从机中配置主从复制'>11.在从机中配置主从复制</h4>
<pre><code class='language-sql' lang='sql'>mysql&gt; change master to master_host=&#39;120.46.175.114&#39;, master_user=&#39;slave&#39;, master_password=&#39;123456&#39;, master_port=3307, master_log_file=&#39;mall-mysql-bin.000001&#39;, master_log_pos=713, master_connect_retry=30;
</code></pre>
<p>&nbsp;</p>
<p>主从复制命令参数说明：</p>
<pre><code>master_host：主数据库的IP地址；
master_port：主数据库的运行端口；
master_user：在主数据库创建的用于同步数据的用户账号；
master_password：在主数据库创建的用于同步数据的用户密码；
master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数；
master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数；
master_connect_retry：连接失败重试的时间间隔，单位为秒。
</code></pre>
<h4 id='12在从机中查看主从复制状态'>12.在从机中查看主从复制状态</h4>
<pre><code class='language-sql' lang='sql'>mysql&gt; show slave status \G;
</code></pre>
<p>主从复制还未开始</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\image-20230524110146034.png" referrerpolicy="no-referrer" alt="image-20230524110146034"></p>
<h4 id='13在从机开启主从复制'>13.在从机开启主从复制</h4>
<pre><code class='language-sql' lang='sql'>mysql&gt; start slave;
</code></pre>
<h4 id='14查看从机状态'>14.查看从机状态</h4>
<pre><code class='language-sql' lang='sql'>mysql&gt; show slave status\G;
</code></pre>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\image-20230524140424887.png" referrerpolicy="no-referrer" alt="image-20230524140424887"></p>
<h4 id='15主机建库建表写入数据'>15.主机建库，建表，写入数据</h4>
<h4 id='16查看从机数据'>16.查看从机数据</h4>
<h3 id='redis集群'>Redis集群</h3>
<p>大数据量解决方案：</p>
<h4 id='哈希取余分区'>哈希取余分区</h4>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1658996785793-2ca8867b-2254-45ee-8bc7-8f566d737db2.png" referrerpolicy="no-referrer" alt="image.png"></p>
<p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：</p>
<p>hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。</p>
<p>优点：</p>
<p>  简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p>
<p>缺点：</p>
<p>   原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)/3会变成Hash(key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。</p>
<p>某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p>
<h4 id='一致性哈希算法分区'>一致性哈希算法分区</h4>
<ol start='' >
<li><p>是什么</p>
<p>一致性Hash算法背景</p>
<p>　　一致性哈希算法在1997年由麻省理工学院中提出的，设计目标是为了解决分布式缓存数据变动和映射问题，某个机器宕机了，分母数量改变了，自然取余数不行了。</p>
</li>
<li><p>能干什么</p>
<p>提出一致性Hash解决方案。 目的是当服务器个数发生变动时， 尽量减少影响客户端到服务器的映射关系</p>
</li>
<li><p>3大步骤</p>
<ul>
<li><p>算法构建一致哈希环</p>
<p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32^-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 = 2^32^),这样让它逻辑上形成了一个环形空间。</p>
<p>它也是按照使用取模的方法，前面笔记介绍的节点取模法是对节点（服务器）的数量进行取模。而一致性Hash算法是对2^32^ 取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32^-1 （即哈希值是一个32位无符号整形），整个哈希环如下图：整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、……直到2^32^-1 ，也就是说0点左侧的第一个点代表2^32^-1， 0和2^32^-1 在零点中方向重合，我们把这个由2^32^个点组成的圆环称为Hash环。</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1658999862145-25f18b54-2e15-47f3-a873-a5d44a16f866.png" referrerpolicy="no-referrer" alt="image.png"></p>
</li>
<li><p>服务器IP节点映射</p>
<p>将集群中各个IP节点映射到环上的某一个位置。</p>
<p>  将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。假如4个节点NodeA、B、C、D，经过IP地址的哈希函数计算(hash(ip))，使用IP地址哈希后在环空间的位置如下： </p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1658999891472-39767eb6-5396-4b43-9cfb-71103e0758ec.png" referrerpolicy="no-referrer" alt="image.png"></p>
</li>
<li><p>key落到服务器的落键规则</p>
<p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p>
<p>如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1658999908647-d6826cc9-9435-4701-8e42-9aaf09cee0be.png" referrerpolicy="no-referrer" alt="image.png"></p>
</li>

</ul>
</li>
<li><p>优点</p>
<ul>
<li><p>容错性</p>
<p>假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1658999941543-94276993-0b80-4c0d-8804-662831456bc2.png" referrerpolicy="no-referrer" alt="image.png"></p>
</li>
<li><p>一致性哈希算法的扩展性</p>
<p>数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可，</p>
<p>不会导致hash取余全部数据重新洗牌。</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1659000035920-385ef89f-50cc-497a-9954-b91df3b4e84a.png" referrerpolicy="no-referrer" alt="image.png"></p>
</li>

</ul>
</li>
<li><p>缺点：</p>
<ul>
<li><p>一致性哈希算法的数据倾斜问题</p>
<p>一致性Hash算法在服务节点太少时，容易因为节点分布不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，</p>
<p>例如系统中只有两台服务器：</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1659000055531-fe1191aa-34b3-46d8-9981-b7ff2ad7f2a7.png" referrerpolicy="no-referrer" alt="image.png"></p>
</li>

</ul>
</li>
<li><p>总结：</p>
<p>为了在节点数目发生改变时尽可能少的迁移数据</p>
<p>将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到临近的存储节点存放。</p>
<p>而当有节点加入或退出时仅影响该节点在Hash环上顺时针相邻的后续节点。  </p>
<p>优点</p>
<p>  加入和删除节点只影响哈希环中顺时针方向的相邻的节点，对其他节点无影响。</p>
<p>缺点 </p>
<p>  数据的分布和节点的位置有关，因为这些节点不是均匀的分布在哈希环上的，所以数据在进行存储时达不到均匀分布的效果。</p>
</li>

</ol>
<h4 id='哈希槽分区'>哈希槽分区</h4>
<ol start='' >
<li><p>是什么：</p>
<ul>
<li><p>为什么出现：</p>
<p>用于解决一致性哈希算法的数据倾斜问题。哈希槽实质就是一个数组，数组[0,2^14^ -1]形成hash slot空间。</p>
</li>
<li><p>能干什么：</p>
<p>解决均匀分配的问题，在数据和节点之间又加入了一层，把这层称为哈希槽（slot），用于管理数据和节点之间的关系，现在就相当于节点上放的是槽，槽里放的是数据。</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1659000487455-b7174e19-35ee-472e-8884-2fad95f1edbc.png" referrerpolicy="no-referrer" alt="image.png"></p>
<p>  槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动。</p>
<p>  哈希解决的是映射问题，使用key的哈希值来计算所在的槽，便于数据分配。</p>
</li>
<li><p>有多少个hash槽</p>
<p>一个集群只能有16384个槽，编号0-16383（0-2^14^-1）。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点。集群会记录节点和槽的对应关系。解决了节点和槽的关系后，接下来就需要对key求哈希值，然后对16384取余，余数是几key就落入对应的槽里。slot = CRC16(key) % 16384。以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了。</p>
</li>

</ul>
</li>
<li><p>哈希槽计算</p>
</li>

</ol>
<p>  Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1659000531546-75739be6-1aee-4165-9dfb-6ac727deddf6.png" referrerpolicy="no-referrer" alt="image.png"></p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1659000521473-2a5a3350-1bd4-4394-b4dd-496f4e024034.png" referrerpolicy="no-referrer" alt="image.png"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h4 id='三主三从redis集群'>三主三从Redis集群</h4>
<h5 id='1启动六个redis应用'>1.启动六个Redis应用</h5>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW conf]# docker run -d --name redis-node-1 --net host --privileged=true -v /home/share/redis-node-1:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6381
Unable to find image &#39;redis:6.0.8&#39; locally
6.0.8: Pulling from library/redis
bb79b6b2107f: Pull complete 
1ed3521a5dcb: Pull complete 
5999b99cee8f: Pull complete 
3f806f5245c9: Pull complete 
f8a4497572b2: Pull complete 
eafe3b6b8d06: Pull complete 
Digest: sha256:21db12e5ab3cc343e9376d655e8eabbdbe5516801373e95a8a9e66010c5b8819
Status: Downloaded newer image for redis:6.0.8
d92573c022434433927940c7b64685d973d6d09cc5b946ece41c810ab047fd36
[root@HW-GDW conf]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                                                  NAMES
d92573c02243   redis:6.0.8    &quot;docker-entrypoint.s…&quot;   6 seconds ago   Up 5 seconds                                                          redis-node-1
8e920228bd7b   mysql:8.0.33   &quot;docker-entrypoint.s…&quot;   24 hours ago    Up 24 hours    33060/tcp, 0.0.0.0:3308-&gt;3306/tcp, :::3308-&gt;3306/tcp   mysql-slave
723bab94c8b5   mysql:8.0.33   &quot;docker-entrypoint.s…&quot;   40 hours ago    Up 40 hours    33060/tcp, 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/tcp   mysql-main
[root@HW-GDW conf]# docker ps
CONTAINER ID   IMAGE          COMMAND                  CREATED          STATUS          PORTS                                            
d92573c02243   redis:6.0.8    &quot;docker-entrypoint.s…&quot;   20 seconds ago   Up 18 seconds                                                    
8e920228bd7b   mysql:8.0.33   &quot;docker-entrypoint.s…&quot;   24 hours ago     Up 24 hours     33060/tcp, 0.0.0.0:3308-&gt;3306/tcp, :::3308-&gt;3306/
723bab94c8b5   mysql:8.0.33   &quot;docker-entrypoint.s…&quot;   40 hours ago     Up 40 hours     33060/tcp, 0.0.0.0:3307-&gt;3306/tcp, :::3307-&gt;3306/
[root@HW-GDW conf]# docker run -d --name redis-node-2 --net host --privileged=true -v /home/share/redis-node-2:/data redis:6.0.8 --cluste-enabled yes --appendonly yes --port 6382
a778e128deaa39d283160939df9167b8fa7fe067a01caa628ab2e800865c7b7f
[root@HW-GDW conf]# docker run -d --name redis-node-3 --net host --privileged=true -v /home/share/redis-node-3:/data redis:6.0.8 --cluste-enabled yes --appendonly yes --port 6383
bc43f76c007584202d0475e6efcb376b52e4bb32f62093faf414b404415dc244
[root@HW-GDW conf]# docker run -d --name redis-node-4 --net host --privileged=true -v /home/share/redis-node-4:/data redis:6.0.8 --cluste-enabled yes --appendonly yes --port 6384
2b477a23168b80f7b7edacc77edeebd3d3fa3b52ccb46bb4a289e32b9d6d2267
[root@HW-GDW conf]# docker run -d --name redis-node-5 --net host --privileged=true -v /home/share/redis-node-5:/data redis:6.0.8 --cluste-enabled yes --appendonly yes --port 6385
021e82d9d25afd230d9db7a76fa843dc2c4d2ac8f654bd76f1b65ffd3061e347
[root@HW-GDW conf]# docker run -d --name redis-node-6 --net host --privileged=true -v /home/share/redis-node-6:/data redis:6.0.8 --cluste-enabled yes --appendonly yes --port 6386
99a6e180668f2c4f6a76f5561e513d0791b59b0876f539ddd80dcfc2d373af43
</code></pre>
<pre><code class='language-shell' lang='shell'>命令分步解释

docker run
创建并运行docker容器实例

--name redis-node-6
容器名字

--net host
使用宿主机的IP和端口，默认

--privileged=true
获取宿主机root用户权限

-v /data/redis/share/redis-node-6:/data
容器卷，宿主机地址:docker内部地址

redis:6.0.8
redis镜像和版本号

--cluster-enabled yes
开启redis集群

--appendonly yes
开启持久化

--port 6386
redis端口号
</code></pre>
<h5 id='2-进入node1'>2. 进入node1</h5>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW conf]# docker exec -it redis-node-1 /bin/bash
</code></pre>
<h5 id='3设置主从关系'>3.设置主从关系</h5>
<pre><code class='language-shell' lang='shell'>redis-cli --cluster create 192.168.0.186:6381 192.168.0.186:6382 192.168.0.186:6383 192.168.0.186:6384 192.168.0.186:6385 192.168.0.186:6386 --cluster-replicas 1
</code></pre>
<pre><code class='language-shell' lang='shell'>--cluster create [IP:端口],[IP:端口]……
cluster-replicas [每个主节点有几个从节点]
</code></pre>
<p>将全部节点输入，设置一个主节点有一个从节点，Redis会自动分配主从关系</p>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster create 192.168.0.186:6381 192.168.0.186:6382 192.168.0.186:6383 192.168.0.186:6384 192.168.0.186:65 192.168.0.186:6386 --cluster-replicas 1
&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...
Master[0] -&gt; Slots 0 - 5460
Master[1] -&gt; Slots 5461 - 10922
Master[2] -&gt; Slots 10923 - 16383
Adding replica 192.168.0.186:6385 to 192.168.0.186:6381
Adding replica 192.168.0.186:6386 to 192.168.0.186:6382
Adding replica 192.168.0.186:6384 to 192.168.0.186:6383
&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity
[WARNING] Some slaves are in the same host as their master
M: 73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381
   slots:[0-5460] (5461 slots) master
M: c68987d0196d7a084f6aae4b759b7355d65be735 192.168.0.186:6382
   slots:[5461-10922] (5462 slots) master
M: 92a06fa456b049733916525b04cf557c49be4468 192.168.0.186:6383
   slots:[10923-16383] (5461 slots) master
S: ada9404ea8ea4ae4b81cce9c808c333ba3eb7718 192.168.0.186:6384
   replicates 92a06fa456b049733916525b04cf557c49be4468
S: ac626dd49193e9b321aa69dd7f1b01bada7a3799 192.168.0.186:6385
   replicates 73c27796c8f75a7dd8062572ece8e8a991eb15fb
S: c26af594fd59ec46c35f86510bb5c6041c9563d9 192.168.0.186:6386
   replicates c68987d0196d7a084f6aae4b759b7355d65be735
Can I set the above configuration? (type &#39;yes&#39; to accept): yes
&gt;&gt;&gt; Nodes configuration updated
&gt;&gt;&gt; Assign a different config epoch to each node
&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join
.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.186:6381)
M: 73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
S: ada9404ea8ea4ae4b81cce9c808c333ba3eb7718 192.168.0.186:6384
   slots: (0 slots) slave
   replicates 92a06fa456b049733916525b04cf557c49be4468
M: 92a06fa456b049733916525b04cf557c49be4468 192.168.0.186:6383
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
S: c26af594fd59ec46c35f86510bb5c6041c9563d9 192.168.0.186:6386
   slots: (0 slots) slave
   replicates c68987d0196d7a084f6aae4b759b7355d65be735
M: c68987d0196d7a084f6aae4b759b7355d65be735 192.168.0.186:6382
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
S: ac626dd49193e9b321aa69dd7f1b01bada7a3799 192.168.0.186:6385
   slots: (0 slots) slave
   replicates 73c27796c8f75a7dd8062572ece8e8a991eb15fb
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre>
<h4 id='4查看集群状态'>4.查看集群状态</h4>
<p>查看集群简要信息：</p>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW conf]# docker exec -it redis-node-1 /bin/bash
root@HW-GDW:/data# redis-cli      
Could not connect to Redis at 127.0.0.1:6379: Connection refused
not connected&gt; 
not connected&gt; 
root@HW-GDW:/data# redis-cli -p 6381
127.0.0.1:6381&gt; CLUSTER INFO
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:1151
cluster_stats_messages_pong_sent:1083
cluster_stats_messages_sent:2234
cluster_stats_messages_ping_received:1078
cluster_stats_messages_pong_received:1151
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:2234
</code></pre>
<p>查看集群详细信息：</p>
<pre><code class='language-shell' lang='shell'>127.0.0.1:6381&gt; CLUSTER NODES
ada9404ea8ea4ae4b81cce9c808c333ba3eb7718 192.168.0.186:6384@16384 slave 92a06fa456b049733916525b04cf557c49be4468 0 1684986415863 3 connected
73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381@16381 myself,master - 0 1684986413000 1 connected 0-5460
92a06fa456b049733916525b04cf557c49be4468 192.168.0.186:6383@16383 master - 0 1684986415000 3 connected 10923-16383
c26af594fd59ec46c35f86510bb5c6041c9563d9 192.168.0.186:6386@16386 slave c68987d0196d7a084f6aae4b759b7355d65be735 0 1684986413860 2 connected
c68987d0196d7a084f6aae4b759b7355d65be735 192.168.0.186:6382@16382 master - 0 1684986414862 2 connected 5461-10922
ac626dd49193e9b321aa69dd7f1b01bada7a3799 192.168.0.186:6385@16385 slave 73c27796c8f75a7dd8062572ece8e8a991eb15fb 0 1684986414000 1 connected
</code></pre>
<h4 id='主从容错切换迁移'>主从容错切换迁移</h4>
<h5 id='数据读写存储'>数据读写存储</h5>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW conf]# docker exec -it redis-node-1 /bin/bash
root@HW-GDW:/data# redis-cli -p 6381
127.0.0.1:6381&gt; set k1 v1
(error) MOVED 12706 192.168.0.186:6383
</code></pre>
<p>k1经过计算后 哈希值取余后超过了5460，分配到了redis-node-3，无法储存</p>
<pre><code class='language-shel' lang='shel'>root@HW-GDW:/data# redis-cli -p 6381 -c
127.0.0.1:6381&gt; FLUSHALL
OK
127.0.0.1:6381&gt; set k1 v1
-&gt; Redirected to slot [12706] located at 192.168.0.186:6383
OK
192.168.0.186:6383&gt; set k2 v2
-&gt; Redirected to slot [449] located at 192.168.0.186:6381
OK
192.168.0.186:6381&gt; set k4 v4
-&gt; Redirected to slot [8455] located at 192.168.0.186:6382
OK
</code></pre>
<p>参数加上-c 可以连接到集群</p>
<h5 id='查看集群信息'>查看集群信息</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster check 192.168.0.186:6381
192.168.0.186:6381 (73c27796...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.0.186:6383 (92a06fa4...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.0.186:6382 (c68987d0...) -&gt; 1 keys | 5462 slots | 1 slaves.
[OK] 3 keys in 3 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.186:6381)
M: 73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
M: 92a06fa456b049733916525b04cf557c49be4468 192.168.0.186:6383
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
S: ac626dd49193e9b321aa69dd7f1b01bada7a3799 192.168.0.186:6385
   slots: (0 slots) slave
   replicates 73c27796c8f75a7dd8062572ece8e8a991eb15fb
M: c68987d0196d7a084f6aae4b759b7355d65be735 192.168.0.186:6382
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
S: ada9404ea8ea4ae4b81cce9c808c333ba3eb7718 192.168.0.186:6384
   slots: (0 slots) slave
   replicates 92a06fa456b049733916525b04cf557c49be4468
S: c26af594fd59ec46c35f86510bb5c6041c9563d9 192.168.0.186:6386
   slots: (0 slots) slave
   replicates c68987d0196d7a084f6aae4b759b7355d65be735
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre>
<p>&nbsp;</p>
<h4 id='主从扩容'>主从扩容</h4>
<h5 id='1新增主机6387-6388'>1.新增主机6387 6388</h5>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW ~]# docker run -d --name redis-node-8 --net host --privileged=true -v /home/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6387
[root@HW-GDW ~]# docker run -d --name redis-node-8 --net host --privileged=true -v /home/share/redis-node-8:/data redis:6.0.8 --cluster-enabled yes --appendonly yes --port 6388
</code></pre>
<h5 id='2进入6387'>2.进入6387</h5>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW ~]# docker exec -it redis-node-7 /bin/bash
</code></pre>
<h5 id='3将新增的的6387节点空槽号）作为master节点加入原集群'>3.将新增的的6387节点（空槽号）作为master节点加入原集群</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster add-node 192.168.0.186:6387 192.168.0.186:6381
</code></pre>
<h5 id='4检查集群状态'>4.检查集群状态</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster check 192.168.0.186:6381
192.168.0.186:6381 (73c27796...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.0.186:6383 (92a06fa4...) -&gt; 1 keys | 5461 slots | 1 slaves.
192.168.0.186:6387 (41588d7e...) -&gt; 0 keys | 0 slots | 0 slaves.
192.168.0.186:6382 (c68987d0...) -&gt; 1 keys | 5462 slots | 1 slaves.
[OK] 3 keys in 4 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.186:6381)
M: 73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381
   slots:[0-5460] (5461 slots) master
   1 additional replica(s)
M: 92a06fa456b049733916525b04cf557c49be4468 192.168.0.186:6383
   slots:[10923-16383] (5461 slots) master
   1 additional replica(s)
M: 41588d7edcc4cc58b9a60996718022095ce0eebe 192.168.0.186:6387
   slots: (0 slots) master
S: ac626dd49193e9b321aa69dd7f1b01bada7a3799 192.168.0.186:6385
   slots: (0 slots) slave
   replicates 73c27796c8f75a7dd8062572ece8e8a991eb15fb
M: c68987d0196d7a084f6aae4b759b7355d65be735 192.168.0.186:6382
   slots:[5461-10922] (5462 slots) master
   1 additional replica(s)
S: ada9404ea8ea4ae4b81cce9c808c333ba3eb7718 192.168.0.186:6384
   slots: (0 slots) slave
   replicates 92a06fa456b049733916525b04cf557c49be4468
S: c26af594fd59ec46c35f86510bb5c6041c9563d9 192.168.0.186:6386
   slots: (0 slots) slave
   replicates c68987d0196d7a084f6aae4b759b7355d65be735
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
</code></pre>
<h5 id='5重新分配槽位'>5.重新分配槽位</h5>
<pre><code class='language-shell' lang='shell'>redis-cli --cluster reshard 192.168.0.186:6381
</code></pre>
<h5 id='6重新查看集群信息'>6.重新查看集群信息</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster check 192.168.0.186:6381
</code></pre>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster check 192.168.0.186:6381
192.168.0.186:6381 (73c27796...) -&gt; 0 keys | 4096 slots | 1 slaves.
192.168.0.186:6383 (92a06fa4...) -&gt; 1 keys | 4096 slots | 1 slaves.
192.168.0.186:6387 (41588d7e...) -&gt; 1 keys | 4096 slots | 0 slaves.
192.168.0.186:6382 (c68987d0...) -&gt; 1 keys | 4096 slots | 1 slaves.
[OK] 3 keys in 4 masters.
0.00 keys per slot on average.
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.186:6381)
M: 73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381
   slots:[1365-5460] (4096 slots) master
   1 additional replica(s)
M: 92a06fa456b049733916525b04cf557c49be4468 192.168.0.186:6383
   slots:[12288-16383] (4096 slots) master
   1 additional replica(s)
M: 41588d7edcc4cc58b9a60996718022095ce0eebe 192.168.0.186:6387
   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master
S: ac626dd49193e9b321aa69dd7f1b01bada7a3799 192.168.0.186:6385
   slots: (0 slots) slave
   replicates 73c27796c8f75a7dd8062572ece8e8a991eb15fb
M: c68987d0196d7a084f6aae4b759b7355d65be735 192.168.0.186:6382
   slots:[6827-10922] (4096 slots) master
   1 additional replica(s)
S: ada9404ea8ea4ae4b81cce9c808c333ba3eb7718 192.168.0.186:6384
   slots: (0 slots) slave
   replicates 92a06fa456b049733916525b04cf557c49be4468
S: c26af594fd59ec46c35f86510bb5c6041c9563d9 192.168.0.186:6386
   slots: (0 slots) slave
   replicates c68987d0196d7a084f6aae4b759b7355d65be735
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
</code></pre>
<h5 id='7为6387分配6388为从机'>7.为6387分配6388为从机</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster add-node 192.168.0.186:6388 192.168.0.186:6387 --cluster-slave --cluster-master-id 41588d7edcc4cc58b9a60996718022095ce0eebe
</code></pre>
<p>&nbsp;</p>
<h4 id='主从缩容'>主从缩容</h4>
<h5 id='1清除6388'>1.清除6388</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster del-node 192.168.0.186:6388 34cbb43568fc4ec4673337880335a1727c400727
</code></pre>
<h5 id='2将6387的槽号清空重新分配给6381'>2.将6387的槽号清空，重新分配给6381</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster reshard 192.168.0.186:6381
&gt;&gt;&gt; Performing Cluster Check (using node 192.168.0.186:6381)
M: 73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381
   slots:[1365-5460] (4096 slots) master
   1 additional replica(s)
M: 92a06fa456b049733916525b04cf557c49be4468 192.168.0.186:6383
   slots:[12288-16383] (4096 slots) master
   1 additional replica(s)
M: 41588d7edcc4cc58b9a60996718022095ce0eebe 192.168.0.186:6387
   slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master
S: ac626dd49193e9b321aa69dd7f1b01bada7a3799 192.168.0.186:6385
   slots: (0 slots) slave
   replicates 73c27796c8f75a7dd8062572ece8e8a991eb15fb
M: c68987d0196d7a084f6aae4b759b7355d65be735 192.168.0.186:6382
   slots:[6827-10922] (4096 slots) master
   1 additional replica(s)
S: ada9404ea8ea4ae4b81cce9c808c333ba3eb7718 192.168.0.186:6384
   slots: (0 slots) slave
   replicates 92a06fa456b049733916525b04cf557c49be4468
S: c26af594fd59ec46c35f86510bb5c6041c9563d9 192.168.0.186:6386
   slots: (0 slots) slave
   replicates c68987d0196d7a084f6aae4b759b7355d65be735
[OK] All nodes agree about slots configuration.
&gt;&gt;&gt; Check for open slots...
&gt;&gt;&gt; Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)? 4096
What is the receiving node ID? 73c27796c8f75a7dd8062572ece8e8a991eb15fb
Please enter all the source node IDs.
  Type &#39;all&#39; to use all the nodes as source nodes for the hash slots.
  Type &#39;done&#39; once you entered all the source nodes IDs.
Source node #1: 41588d7edcc4cc58b9a60996718022095ce0eebe
Source node #2: done                                           

Ready to move 4096 slots.
  Source nodes:
    M: 41588d7edcc4cc58b9a60996718022095ce0eebe 192.168.0.186:6387
       slots:[0-1364],[5461-6826],[10923-12287] (4096 slots) master
  Destination node:
    M: 73c27796c8f75a7dd8062572ece8e8a991eb15fb 192.168.0.186:6381
       slots:[1365-5460] (4096 slots) master
       1 additional replica(s)
</code></pre>
<h5 id='3查看集群状态'>3.查看集群状态</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster check 192.168.0.186:6381
192.168.0.186:6381 (73c27796...) -&gt; 1 keys | 8192 slots | 1 slaves.
192.168.0.186:6383 (92a06fa4...) -&gt; 1 keys | 4096 slots | 1 slaves.
192.168.0.186:6387 (41588d7e...) -&gt; 0 keys | 0 slots | 0 slaves.
192.168.0.186:6382 (c68987d0...) -&gt; 1 keys | 4096 slots | 1 slaves.
</code></pre>
<h5 id='4删除6387节点'>4.删除6387节点</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster del-node 192.168.0.186:6387 41588d7edcc4cc58b9a60996718022095ce0eebe
&gt;&gt;&gt; Removing node 41588d7edcc4cc58b9a60996718022095ce0eebe from cluster 192.168.0.186:6387
&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...
&gt;&gt;&gt; Sending CLUSTER RESET SOFT to the deleted node.
</code></pre>
<h5 id='5查看集群状态'>5.查看集群状态</h5>
<pre><code class='language-shell' lang='shell'>root@HW-GDW:/data# redis-cli --cluster check 192.168.0.186:6381
192.168.0.186:6381 (73c27796...) -&gt; 1 keys | 8192 slots | 1 slaves.
192.168.0.186:6383 (92a06fa4...) -&gt; 1 keys | 4096 slots | 1 slaves.
192.168.0.186:6382 (c68987d0...) -&gt; 1 keys | 4096 slots | 1 slaves.
[OK] 3 keys in 3 masters.
0.00 keys per slot on average.
</code></pre>
<h2 id='dockerfile-2'>DockerFile</h2>
<h3 id='是什么'>是什么</h3>
<p>DokerFile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p>
<h3 id='概述'>概述</h3>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1660012864805-18937b87-0167-4c81-9d75-f485a61c5304.png" referrerpolicy="no-referrer" alt="image.png"></p>
<h3 id='官网'>官网</h3>
<blockquote><p><a href='https://docs.docker.com/engine/reference/builder/' target='_blank' class='url'>https://docs.docker.com/engine/reference/builder/</a></p>
</blockquote>
<h3 id='构建步骤'>构建步骤</h3>
<ol start='' >
<li>编写Dockerfile文件</li>
<li>docker build 命令构建镜像</li>
<li>docker run 镜像 运行实例</li>

</ol>
<h3 id='dockerfile构建过程解析'>DockerFile构建过程解析</h3>
<h4 id='dockerfile内容基础知识'>Dockerfile内容基础知识</h4>
<ol start='' >
<li>每条保留字执行都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li>#代表注释</li>
<li>每条指令都会穿件一个新的镜像层并对镜像进行提交</li>

</ol>
<h3 id='docker执行dockerfile的大致流程'>Docker执行Dockerfile的大致流程</h3>
<ol start='' >
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出改变</li>
<li>执行类似docker commit的操作提交一个新的镜像层</li>
<li>docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfile中的下一条指令直到所有指令都执行完成</li>

</ol>
<h3 id='dockerfile常用保留字指令'>DockerFile常用保留字指令</h3>
<blockquote><p>FROM</p>
</blockquote>
<p>基础镜像，当前新镜像是基于那个镜像，指定一个已经存在的镜像作为基底，第一条必须是FROM</p>
<blockquote><p>MAINTAINER</p>
</blockquote>
<p>镜像维护者的姓名和邮箱地址</p>
<blockquote><p>RUN</p>
</blockquote>
<p>容器构建时需要运行的命令</p>
<p>两种格式</p>
<blockquote><p>1.shell格式</p>
<blockquote><p>RUN &lt;命令行命令&gt;</p>
<p>#&lt;命令行命令&gt;等同于，在终端操作的shell命令。</p>
<p>RUN yum -y install vim</p>
</blockquote>
<p>2.exec格式</p>
<blockquote><p>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</p>
<p>#例如：</p>
<p>#RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</p>
</blockquote>
</blockquote>
<p>RUN是在docker build时运行</p>
<blockquote><p>EXPOSE</p>
</blockquote>
<p>当前容器对外暴露出的端口</p>
<blockquote><p>WORKDIR</p>
</blockquote>
<p>指定在创建容器后，终端默认登录进来的工作目录</p>
<blockquote><p>USER</p>
</blockquote>
<p>指定该镜像以什么样的用户去执行</p>
<blockquote><p>ENV</p>
</blockquote>
<p>用来在构建镜像过程中设置环境变量</p>
<blockquote><p>ENV MY_PATH /usr/mytest</p>
<p>这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样</p>
<p>也可以在其他指令中直接使用这些环境变量</p>
<p>比如： WORKDIR $MY_PATH</p>
</blockquote>
<p>&nbsp;</p>
<blockquote><p>ADD</p>
</blockquote>
<p>将宿主机目录下的文件拷贝进镜像且会自动处理URL和解压tar压缩包</p>
<blockquote><p>COPY</p>
</blockquote>
<p>类似ADD，拷贝文件和目录到镜像中。</p>
<p>将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</p>
<blockquote><p>COPY src dest</p>
<p>COPY [&quot;src&quot;, &quot;dest&quot;]</p>
<p>&lt;src源路径&gt;：源文件或者源目录</p>
<p>&lt;dest目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p>
</blockquote>
<p>&nbsp;</p>
<blockquote><p>VOLUME</p>
</blockquote>
<p>容器数据卷，用于数据保存和持久化工作</p>
<blockquote><p>CMD</p>
</blockquote>
<p>指定容器启动后的要干的事情</p>
<p>注意：</p>
<p>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换。</p>
<blockquote><p>CMD [&quot;catalina.sh&quot;, &quot;run&quot;]</p>
</blockquote>
<p>它和前面RUN命令的区别</p>
<ul>
<li>CMD是在docker run时运行</li>
<li>RUN是在docker build是运行</li>

</ul>
<blockquote><p>ENTRYPOINT</p>
</blockquote>
<p>也是用来指定一个容器 启动时要运行的命令</p>
<p>类似于CMD指令，但是ENTRYPOINT不会被docker run后面的命令覆盖，而且这些命令行参数会被当做参数送给ENTRYPOINT指令指定的程序。</p>
<p>&nbsp;</p>
<blockquote><p>命令格式：</p>
<p>ENTRYPOINT可以和CMD一起用，一般变参才会使用CMD，这里的CMD等于是在给ENTRYPOINT传参。</p>
<p>当指定了ENTRYPOINT后，CMD的含义就发生了变化，不再是直接运行其命令而是将CMD的内容作为参数传递给ENTRYPOINT指令，这两个组合会变成</p>
<p><ENTRYPOINT>&quot;<CMD>&quot;</p>
</blockquote>
<p>优点：在执行docker run的时候可以指定 ENTRYPOINT 运行所需的参数。</p>
<p>注意：如果Dockerfile 中如果存在多个 ENTRYPOINT 指令，进最后一个生效</p>
<p>&nbsp;</p>
<p>总结：</p>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\1660013999567-eea06f1d-f9ac-425e-a851-c5dda92b5ce5.png" referrerpolicy="no-referrer" alt="image.png"></p>
<h3 id='自定义镜像mycentos-java8'>自定义镜像mycentos-java8</h3>
<h4 id='1编写dockerfile文件并将jkd放到同一目录下'>1.编写DockerFile文件并将jkd放到同一目录下</h4>
<pre><code class='language-dockerfile' lang='dockerfile'>FROM centos:7
MAINTAINER gdw&lt;gdw@123.com&gt;

ENV MYPATH /usr/local
WORKDIR $MYPATH

#安装vim编辑器
RUN yum -y install vim
#安装ifconfig命令
RUN yum -y install net-tools
#安装JAVA8及lib库
RUN yum -y install glibc.i686
RUN mkdir /usr/local/java
#ADD 是相对路径jar,把jdk-8u151-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置
ADD jdk-8u151-linux-x64.tar.gz /usr/local/java/
#配置java环境变量
ENV JAVA_HOME /usr/local/java/jdk1.8.0_151
ENV JRE_HOME $JAVA_HOME/jre
ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib:$CLASSPATH
ENV PATH $JAVA_HOME/bin:$PATH

EXPOSE 80

CMD echo $MYPATH
CMD echo &quot;succes---------ok&quot;
CMD /bin/bash
</code></pre>
<h4 id='2构建镜像'>2.构建镜像</h4>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW home]# docker build -t centos-java8:1.0 .
</code></pre>
<h4 id='3启动镜像'>3.启动镜像</h4>
<pre><code class='language-shell' lang='shell'>[root@HW-GDW home]# docker run -it centos-java:1.0
</code></pre>
<h2 id='docker微服务实战'>Docker微服务实战</h2>
<h3 id='通过idea新建一个普通微服务模块'>通过IDEA新建一个普通微服务模块</h3>
<p><img src="C:\Users\GDW\Desktop\笔记\Docker\Docker.assets\image-20230529085637590.png" referrerpolicy="no-referrer" alt="image-20230529085637590"></p>
<h3 id='修改pom文件'>修改POM文件</h3>
<pre><code class='language-xml' lang='xml'>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.6&lt;/version&gt;
        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
    &lt;/parent&gt;
    &lt;groupId&gt;com.gdw&lt;/groupId&gt;
    &lt;artifactId&gt;DockerBoot&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;name&gt;DockerBoot&lt;/name&gt;
    &lt;description&gt;DockerBoot&lt;/description&gt;
    &lt;properties&gt;
        &lt;java.version&gt;8&lt;/java.version&gt;

        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
        &lt;junit.version&gt;4.12&lt;/junit.version&gt;
        &lt;log4j.version&gt;1.2.17&lt;/log4j.version&gt;
        &lt;lombok.version&gt;1.16.18&lt;/lombok.version&gt;
        &lt;mysql.version&gt;5.1.47&lt;/mysql.version&gt;
        &lt;druid.version&gt;1.1.16&lt;/druid.version&gt;
        &lt;mapper.version&gt;4.1.5&lt;/mapper.version&gt;
        &lt;mybatis.spring.boot.version&gt;1.3.0&lt;/mybatis.spring.boot.version&gt;

    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;!--SpringBoot通用依赖模块--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--test--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;cn.hutool&lt;/groupId&gt;
            &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;
            &lt;version&gt;5.8.16&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;
</code></pre>
<h3 id='写yml文件'>写YML文件</h3>
<pre><code class='language-yaml' lang='yaml'>server.port=6001
</code></pre>
<h3 id='启动类'>启动类</h3>
<pre><code class='language-java' lang='java'>package com.gdw.dockerboot;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DockerBootApplication {

    public static void main(String[] args) {
        SpringApplication.run(DockerBootApplication.class, args);
    }

}
</code></pre>
<h3 id='业务类'>业务类</h3>
<pre><code class='language-java' lang='java'>package com.gdw.dockerboot.test;

import cn.hutool.http.Header;
import cn.hutool.http.HttpRequest;
import cn.hutool.http.HttpResponse;
import cn.hutool.json.JSON;
import cn.hutool.json.JSONObject;
import cn.hutool.json.JSONUtil;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.UUID;

/**
 * @author GDW
 * @package com.gdw.test
 * @date 2023/5/26 14:50
 */
@RestController
@RequestMapping(&quot;/order&quot;)
public class testController {
    @Value(&quot;${server.port}&quot;)
    private String port;

    @GetMapping(&quot;/docker&quot;)
    public String helloDocker() {
        return &quot;hello docker&quot; + &quot;\t&quot; + port + &quot;\t&quot; + UUID.randomUUID().toString();
    }

    @GetMapping(&quot;/index&quot;)
    public String index() {
        return &quot;服务端口号：&quot; + &quot;\t&quot; + port + &quot;\t&quot; + UUID.randomUUID().toString();
    }
    @GetMapping(&quot;/api&quot;)
    public String api() {
        HttpResponse res = HttpRequest.get(&quot;https://api.wrdan.com/hitokoto&quot;)
                .header(Header.USER_AGENT, &quot;Hutool http&quot;)//头
                .form(null)//表单内容
                .timeout(20000)//超时，毫秒
                .execute();

        JSON parse = JSONUtil.parse(res.body());
        String text = (String) parse.getByPath(&quot;text&quot;);
        return text;
    }
}
</code></pre>
<h3 id='写dockerfile文件'>写Dockerfile文件</h3>
<pre><code class='language-dockerfile' lang='dockerfile'>FROM java:8
  
MAINTAINER GDW

VOLUME /tmp

ADD DockerBoot-0.0.1-SNAPSHOT.jar dockerboot.jar

RUN bash -c &#39;touch /dockerboot.jar&#39;

ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/dockerboot.jar&quot;]

EXPOSE 6001
</code></pre>
<h3 id='构建镜像'>构建镜像</h3>
<pre><code class='language-shell' lang='shell'>docker build -t gdw_docker:1.1
</code></pre>
<h3 id='运行容器-2'>运行容器</h3>
<pre><code class='language-shell' lang='shell'>docker run -d -p 6001:6001 gdw_docker:1.1
</code></pre>
<p>&nbsp;</p>
</body>
</html>